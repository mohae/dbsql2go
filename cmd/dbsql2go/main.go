// Copyright 2016-17 Joel Scoble.
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// dbsql2go is a CLI tool to generate Go struct definitions from tables in a
// database.
package main

import (
	"flag"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"

	"github.com/mohae/dbsql2go"
	"github.com/mohae/dbsql2go/mysql"
)

var appname string

var (
	dbType        string
	dbName        string
	pkgName       string
	server        string
	user          string
	password      string
	out           string
	filePerTable  bool
	includeDBName bool
)

func init() {
	flag.StringVar(&dbType, "rdbms", "", "the target RDBMS")
	flag.StringVar(&dbName, "db", "", "database name")
	flag.StringVar(&user, "user", "", "login user")
	flag.StringVar(&user, "u", "", "login user")
	flag.StringVar(&password, "password", "", "user's password")
	flag.StringVar(&password, "p", "", "user's password")
	flag.StringVar(&server, "server", "", "server location")
	flag.StringVar(&pkgName, "package", "", "name of the package of which the generated code is a part; if empty,the database name will be used")
	flag.StringVar(&out, "out", "", "the output destination: if it doesn't end with a .go extension it will be assumed to be a path relative to the GOPATH/src dir. If empty, it will be the WD.")
	flag.BoolVar(&filePerTable, "separatefiles", false, "use a file per table; each file will use the table's name")
	flag.BoolVar(&includeDBName, "includedbname", false, "prefix each table file with the db name; only used with separate files")
}

func main() {
	os.Exit(realMain())
}

func realMain() int {
	flag.Parse()
	if dbType == "" {
		fmt.Fprintln(os.Stderr, "a rdbms must be specified")
		return 1
	}
	if dbName == "" {
		fmt.Fprintln(os.Stderr, "a db must be specified")
		return 1
	}
	if user == "" {
		fmt.Fprintln(os.Stderr, "a user must be specified")
		return 1
	}
	if password == "" {
		fmt.Fprintln(os.Stderr, "a password must be specified")
		return 1
	}
	// server is optional, depending on the db being used (for now). As such
	// it should be checked when applicable.

	// TODO: thinking about having it use the current dir as the package name
	// and adding a flag to use the dbname as the package name with that flag
	// taking precedence.
	if pkgName == "" {
		pkgName = dbName
	}

	// If the db request is not supported...
	typ, err := dbsql2go.ParseDBType(dbType)
	if err != nil {
		fmt.Fprintf(os.Stderr, "error: %s\n", err)
		return 1
	}

	var DB dbsql2go.DBer
	var imp string // the db specific driver

	// Connect to the DB
	switch typ {
	case dbsql2go.MySQL:
		DB, err = mysql.New(server, user, password, dbName)
		if err != nil {
			fmt.Fprintf(os.Stderr, "error: %s connect: %s\n", typ, err)
			return 1
		}
		imp = mysql.Import()
	}

	// Get gets all of the information for the specified db.
	err = DB.Get()
	if err != nil {
		fmt.Fprintf(os.Stderr, "%s: error: gathering of ", appname)
	}

	w, filename, err := setOutput()
	if err != nil {
		fmt.Fprintf(os.Stderr, "error: %s", err)
		return 1
	}

	// if this is a file, do a defer close
	if _, ok := w.(*os.File); ok {
		defer w.(*os.File).Close()
	}
	// Now that the DB information has been gathered and the output set; process
	// the database info and write to the file.

	// TODO: add support for optional supported methods on generated structs???
	// Write the package name and imports to the file
	_, err = w.Write([]byte(fmt.Sprintf("//%s: %s struct definitions for database tables and views.\n// auto-generated by github.com/mohae/dbsql2go/cmd/dbsql2go\n", pkgName, typ)))
	if err != nil {
		fmt.Fprintf(os.Stderr, "error: package comment: %s\n", err)
		return 1
	}
	_, err = w.Write([]byte(fmt.Sprintf("package %s\n\nimport (\n\t\"database/sql\"\n\n\t%s\n)\n", pkgName, imp)))
	if err != nil {
		fmt.Fprintf(os.Stderr, "error: package statements: %s\n", err)
		return 1
	}

	// Get all the tables; this also gathers all relevant db info.
	tables := DB.Tables()

	// dump all the Go table definitions to file
	// TODO: add support for file per table
	for _, tbl := range tables {
		_, err = w.Write([]byte("\n\n"))
		if err != nil {
			fmt.Fprintf(os.Stderr, "error: writing table separator lines: %s\n", err)
			return 1
		}

		err := tbl.GoFmt(w)
		if err != nil {
			fmt.Fprintf(os.Stderr, "error: generating Go struct definition for %s.%s: %s\n", dbName, tbl.Name(), err)
			return 1
		}
	}
	if filePerTable {
		out = filepath.Join(out, filename)
	}

	fmt.Printf("Go structs were generated from %s and written to %q\n", dbName, out)
	return 0
}

// setOutput sets the initial output writer, ensures the filePerTable flag is
// unset, if applicable, and sets the out destination properly.
//
// If out is empty, the default GOPATH (as of 1.8) will be used. If out
func setOutput() (w io.Writer, filename string, err error) {
	// Figure out the output destination. I feel bad about this hairball.
	if out == "stdout" {
		w = os.Stdin
		// for stdout filePerTable doesn't make sense; make sure its false
		filePerTable = false
		return w, "", nil
	}

	// declarations because of goto
	var (
		i   int
		gop string
	)

	if out == "" {
		// get the wd
		out, err = os.Getwd()
		if err != nil {
			fmt.Fprintf(os.Stderr, "error: get WD: %s\n", err)
			return nil, "", err
		}
		goto output
	}

	// check out for $GOPATH and replace if it exists
	// TODO: support windows
	i = strings.Index(out, "$GOPATH")
	if i >= 0 {
		gop = os.Getenv("GOPATH")
		if gop == "" { // if it wasn't set, use Go's default path (1.8) + src
			gop = "$HOME/go/src"
		}

	}
	out = os.ExpandEnv(out) // expand any other env vars that may be in the path.

	// the out includes a filename, separate that out.
	if filepath.Ext(out) == ".go" {
		filename = filepath.Base(out) // set the filename in this instance
		out = filepath.Dir(out)
	}

output:
	if filePerTable && filename != "" {
		fmt.Printf("dbsql2go: the separatefile flag was set to true and the output destination include a .go extension, the output directory will be %q and each table will be written to its own file", out)
	}

	// make sure the dir exists
	if out != "" {
		err = os.MkdirAll(out, 0766)
		if err != nil {
			fmt.Fprintln(os.Stderr, "error: directory: %s\n", err)
			return nil, "", err
		}
	}
	fmt.Printf("dbsql2go: writing generated .go files to the %q directory\n", out)

	// open the file
	if filename == "" {
		filename = dbName + ".go"
	}

	w, err = os.OpenFile(filepath.Join(out, filename), os.O_CREATE|os.O_RDWR|os.O_TRUNC, 0766)
	if err != nil {
		fmt.Fprintf(os.Stderr, "error: open file: %s\n", err)
		return nil, "", err
	}

	return w, filename, nil
}
